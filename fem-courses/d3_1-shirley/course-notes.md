Shirley!

http://slides.com/shirleywu/fm-d3intro#/
@sxywu
d3.unconf
metis?

# to-do
Read:  https://github.com/d3/d3/blob/master/API.md#selections-d3-selection
Learn: https://bl.ocks.org/-/about
Use:   https://blockbuilder.org/
Use:   https://blockbuilder.org/search


https://github.com/d3/d3/blob/master/API.md

# AGENDA
D3 Ecosystem

Selections
Data binding
Enter-append

Scales
Shapes

Update & Exit
Transitions

Forces

# D3 Ecosystem

API Reference:

Selections
Scales & Axes
Shapes
Forces

Bl.ocks & Blockbuilder (search)


Selections and Data
------------------------------------------------------

https://github.com/d3/d3-selection

```html
  <svg>
    <rect />
    <rect />
    <rect />
    <rect />
    <rect />
  </svg>
  <script>
    var data = [100, 250, 175, 200, 120];
    
    d3.selectAll('rect')
    	.data(data)
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', 'blue')
    	.attr('stroke', '#fff');

  </script>
```

Let's analyse this script:

`d3.select/selectAll('css_selector')`
this returns an array with the DOM elements that you've selected, with some functions wrapped around it.
and then all the functions are available to use on these elements.

`.data(data)`
"here's where I think a lot of the magic happens": with this function you pass in an array of data, and d3 will bind the data, one to one, to the elements in your selection. Apparently it creates a property/attribute `__data__` in the element, and its value is the respective value in the array of data that was passed in.

The core of D3 is this: "you take some data and then you apply/bind it to the DOM element and then you can access the data because it's literally been bound to the element in this way."

```javascript
   	.attr('x', (d, i) => i * rectWidth)
   	.attr('y', d => height - d)
   	.attr('width', rectWidth)
   	.attr('height', d => d)
   	.attr('fill', 'blue')
    .attr('stroke', '#fff');
```
"Then once you've bound that to each of the elements, you can use that data do specify what your element should do" (or look like, I guess).

So what d3 does is: loop through each rectangle in the selection, and passes in the data that's been bound to that specific element, as well as the index of that element in that selection array that was generated by d3.select/selectAll. And then you basically use a function to apply that value, that is, to specify what you want returned as the value of, in this case, an attribute.

For example, in `.attr('x', (d, i) => i * rectWidth)` you're saying, "hey, for each of these rectangle elements, this is what I want my x attribute to be.".

Notar que essa função que vai buscar / calcular o valor que se quer atribuir ao atributo em questão deve sempre ter um `return`, para o d3 conseguir identificar o valor que vai ser usado. No entanto, dentro da definição da função, é possível incluir, por exemplo, um `console.log`.

```js
    d3.selectAll('rect')
    	.data(data)
    	.attr('x', function(d, i) {
        console.log(i, d, i * rectWidth, height - d); // logging
        return i * rectWidth})
    	.attr('y', d => height - d)
```

**svg**

Coordinate system goes like
         x
  0 ---------------- >
  |
  |
y |
  |
  |
  v


Enter - Append
------------------------------------------------------

```html
  <svg></svg>
  <script>
    var rectWidth = 100;
    var height = 300;
    var data = [100, 250, 175, 200, 120];
    
    var svg = d3.select('svg');
    svg.selectAll('rect')
    	.data(data)
    	.enter().append('rect')
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', 'blue')
    	.attr('stroke', '#fff');

  </script>
```

This piece of code gives the same result. It did not explicitly declared the <rect> elements.

But: `svg.selectAll('rect')` --> what are we even selecting?!

It's an empty selection! But how are those bars appearing?

Here's the magic: `.data(data).enter().append('rect')`

> So when we do .data and we enter in the set of data, we pass in the set of data like we did before. This's what .data is calculating. It's saying, here is all my data that I had been posting and this all the rectangle elements that exist on the screen right now which just happens to be zero. Which means I need five rectangles, I need to create five rectangles to match that data. And that's all .data figures out. 

> And then what .enter comes and does is, it says, okay, I need to have five place holders for the right elements to make sure it matches the data. So, it just puts in these five place holders. 

> And then finally, when you .append, it takes those placeholders and actually creates rectangle and rect elements out of them, and also at the same time binds all of that data. Yeah, so that's essentially what's happening for data Enter-Append

Exemplo 2, comentando a sequência.

```js
		var rectWidth = 100;
    var height = 300;
    var data = [100, 250, 175, 200, 120];
    
    var svg = d3.select('svg');
    let enter = svg.selectAll('rect');
//    	.data(data)
//    	.enter().append('rect')
//    	.attr('x', (d, i) => i * rectWidth)
//    	.attr('y', d => height - d)
//    	.attr('width', rectWidth)
//    	.attr('height', d => d)
//    	.attr('fill', 'blue')
//    	.attr('stroke', '#fff');
    console.log(enter);
```
Esse objeto `enter` vai estar vazio.

i. Aí tira o comentário da linha `.data(data)`. O objeto agora vai ter length 5, vazia por dentro.

> So `_groups` is essentially what D3 knows is on the screen.

Em `_enter`, vemos os 5 placeholders, vazios, mas com os respectivos valores de `data` associados.

ii. quando tira o comentário de `.enter()`, vemos os placeholders dentro de `_groups`.

iii. quando finalmente tira o de `.append('rect')`, we get the rectangles elements, with the data bound.

À medida que acrescentamos valores à array de dados, novos elementos vão sendo criados! 

> This is why D3 stands for data driven documents, because the idea is the dom should reflect the data that you have.

Como os valores que estão sendo atribuídos aos atributos vêm de funções, dá para fazer muitas coisas. Tipo, colorir com outra cor as barras de valor superior a tanto. 

> And that's the beauty of D 3 that once you have the data bound, you can do absolutely anything with it. You can return for the functions. You can do anything you want as long as it returns a valid value for that specific attribute.

```js
		var rectWidth = 50;
    var height = 300;
    var data = [100, 250, 175, 200, 120, 230, 50];
    let threshold = 230;
    
    var svg = d3.select('svg');
    let enter = svg.selectAll('rect')
    	.data(data)
    	.enter()
      .append('rect')
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', function(d) {
        if (d > threshold) return 'firebrick'
        else return 'dodgerblue'})
    	.attr('stroke', '#fff');
    console.log(enter);
```
> How to check the state of the DOM elements on the screen and what data has been bound to them?

  <script>
		var rectWidth = 50;
    var height = 300;
    var data = [100, 250, 175, 200, 120, 230, 50];
    let threshold = 230;
    
    var svg = d3.select('svg');
    let selecao = svg.selectAll('rect')
    	.data(data)
    	.enter()
      .append('rect')
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', function(d) {
        if (d>threshold) return 'firebrick'
        else return 'dodgerblue'})
    	.attr('stroke', '#fff');
    console.log(selecao);
    console.log(selecao.nodes());
    console.log(selecao._groups[0]);
  </script>

Esses dois últimos logs retornam essencialmente a mesma coisa.

(Mas `console.log(selecao.nodes() === selecao._groups[0])` retorna `false`.)

```js
  console.log(selecao);
  console.log(selecao.nodes());
  console.log(selecao._groups[0]);
  console.log(selecao.data());
```

Esse `selecao.data()`, com `data()` sem nenhum parâmetro, retorna uma array com os dados que foram amarrados.

> I think there's nothing really special about what D3 is doing So D3 is just supposed to be kind of this utility function, this tool to help you manipulate the DOM. So if you use SVG, if you use Canvas, if you use HTML, D3 is basically just a tool for you to manipulate that.

O exemplo de quando já existem dois <rect> hardcoded dentro de <svg>, e a matriz de dados tem 5 elementos. Com `.data()`, são criados placeholders para os rects que ainda não existem (3) e os dados (os três últimos elementos) são amarrados a esses três rects, e os dois <rect>s já existentes aparecem em `._groups`. Mas depois que é feito um `.append()`, só permanecem em `.groups` os três rects que foram criados por `.append()` (embora ele tenha um length de 5! Muito doido).


Scales and Axes
------------------------------------------------------

https://github.com/d3/d3-scale

> I like to think of it as like data binding is one of the core parts of D3 and then also enter-update-exit is one of the core parts of D3. And I personally maybe in a biased view think that if you just grasp those two the rest of the D3 library makes so much sense. Shirley Wu: Okay, so this is where we kinda go a little bit outside that core part and then just have a little bit of fun or what I think is fun.

Mike Bostock:
> If visualization is constructing “visual representations of abstract data to amplify cognition”, then perhaps the most important concept in D3 is the scale, which maps a dimension of abstract data to a visual variable.

> for my examples thus far we give really nice values, right? Between zero to 200 renders nicely on the screen. But what if you had data whose values were between zero and one. If you just rendered that as height, it won't really show up for you. Or will like, if your height was you know a thousand something. Like 2,000, or 10,000 or something like that.

Types os scale in D3:

* Continuous (Linear, Power, Log, Identity, Time)
* Sequential
* Diverging
* Quantize
* Quantile
* Threshold
* Ordinal (Band, Point)

SCALE: mapping from *data attributes, values (domain)* to *to display (range)*

date  -> x-value
value -> y-value
value -> opacity
etc.

To set the _domain_ and the _range_:

```js
  d3.scaleLinear()
    .domain([min, max]) // input
    .range([min, max]); // output
```

How would you get min and max?
```js
// get min/max
var min = d3.min(data, d => d[city]); // "city" would be the "accessor"
var max = d3.max(data, d => d[city]);

// or use extent, which gives back [min, max]
var extent = d3.extent(data, d => d[city]);

var yScale = d3.scaleLinear()
  .domain(extent)
  .range([height, 0]);
```

Scales I use often

// continuous
d3.scaleLinear()
d3.scaleLog()
d3.scaleTime()

// ordinal
d3.scaleBand()

Ver `d3.timeFormat()`, `d3.scaleQuantize()`, `d3.scaleTime()`

### Axis

https://github.com/d3/d3-axis

Scales are really the mapping, the translation.
To display de axis, there's d3.axis
Takes the scale and renders it, translates it to a set of axis. It renders your axis into the DOM.

```js
// get min/max
var min = d3.min(data, d => d[city]);
var max = d3.max(data, d => d[city]);

// or use extent, which gives back [min, max]
var extent = d3.extent(data, d => d[city]);

var yScale = d3.scaleLinear()
  .domain(extent)
  .range([height, 0]);

// display axis
var yAxis = d3.axisLeft()
  .scale(yScale); // pass in a scale

d3.select('svg')
  // create a group element (o container!) we can translate 
  // so that the axis will be visible in SVG
  .append('g')
  .attr('transform', 'translate(40, 20)')
  // selection.call(yAxis) is the same as yAxis(selection)
  // and an axis will be created within the selection
  .call(yAxis); // render the axis, returns the axis selection.
```

<g> is an svg element that is like a container that helps you have other svg elements inside it.

svg allows you to nest elements, so this <g> is a container where you can nest all the other elements into. an then you can apply transformations to the whole group element.

What d3 does under the hood is creating a bunch of <path> and <text> svg elements -- que serão criados dentro desse <g>.

O translate te permite posicionar os eixos em um local diferente de `0,0`..

Como se formata?

```js
     	var yAxis = d3.axisLeft()
        .ticks(20) // vai por 20 divisões
      	.scale(yScale);
```

`axis.tickFormat([format])`
`axis.tickFormat(d3.format(",.0f"));`

Dá para passar uma função, e aí formatar condicionalmente.

Para ver o objeto:

```js
      let eixo = d3.select('svg').append('g')
        .attr('transform', 'translate(40, 20)')
      	.call(yAxis);
      
      console.log(eixo);
```
Vai exibir isso no console:

ut {_groups: Array(1), _parents: Array(1)}
_groups: Array(1)
0: Array(1)
0: g
childNodes: NodeList(13)
// a lista de elementos que formam o eixo aqui.

Se fizer `console.log(eixo.nodes());`, retorna isso aqui no console (a mesma estrutura anterior, mas a partir do nível 4 de profundidade):

[g]
0: g
childNodes: NodeList(13)

```js
      let texto = eixo.selectAll('text')
      console.log(texto);
      console.log(texto.nodes());
```
 Isso seleciona todos os elementos svgs que são "text", e os loga no console.

Mostra os dados que estão amarrados a esses elementos: `console.log(texto.data());`
  
Formata condicionalmente o texto dos labels:
```js
      let texto2 = eixo.selectAll('text')
        .attr('fill', function(d) {
          return d > 60 ? "red" :  "blue";})
```

Notar que podemos encadear seleções. Nesse exemplo, https://bl.ocks.org/tiagombp/9b899d65f0d2ac77d02a7ef7d7228f4a,
fizemos o seguinte:

```js
      let eixo = d3.select('svg').append('g')
        .attr('transform', 'translate(40, 20)')
      	.call(yAxis);

      let texto2 = eixo.selectAll('text')
        .attr('fill', function(d) {
          return d > 60 ? "red" :  "blue";})
```

```js
console.log(yScale(50)); // o yScale(), como definimos, nada mais é que uma função, para a qual podem ser passados valores. Ele vai retornar a altura em pixels que corresponde a 50 graus, conforme o domínio e o range que foi definido.
```

Notar que quando fizemos:

```js
  let eixo_x = d3.axisBottom()
      .scale(xScale);
```
Esse `eixo_x` é uma função. Para efetivamente criar o eixo no DOM, poderíamos fazer:

`eixo_x(svg.append('g'))`

Onde `svg` representa `d3.select('svg')`.

No exemplo, em vez de fazer assim, fizemos:

```js
  let EixoX = svg //d3.select('svg')
    .append('g')
    .call(eixo_x);
```

No `d3.axis` também podemos acrescentar `.ticks(qde_ticks)`, ou:
`.tickFormat(d => d.getMonth())`
ou
`.tickFormat(d => d3.timeFormat('%b %Y')(d));`
que dá no mesmo que:
`.tickFormat(d3.timeFormat('%b %Y'))`


### Exercício!
1. draw the bars using the right scales
2. get the axes


Shapes
------------------------------------------------------

SVG Elements: rect, circle, text, path etc.

For `<path>`: https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths

### d3.shapes

#### Line charts with `d3.line()`

d3-shape calculates the path attribute so we don't have to
https://github.com/d3/d3-shape

Curves: different functions for different types of curves.

d3.line() figures out the path attribute such that it just draws a line through all of these points.

Cria uma função que vai converter os dados passados a ela num <path> que conecte todos os pontos dos dados, por meio de linhas e curvas.

`d3.line()`:
Input: array of objects (the objects being the data points do be plotted).
Output: path that connects each point (object) with lines or curves. (`d3.curve*` oferece várias opções de suavização)

```js
var data = [
  {date: new Date(2007, 3, 24), value: 93.24},
  {date: new Date(2007, 3, 25), value: 95.35},
  {date: new Date(2007, 3, 26), value: 98.84},
  {date: new Date(2007, 3, 27), value: 99.92},
  {date: new Date(2007, 3, 30), value: 99.80},
  {date: new Date(2007, 4,  1), value: 99.47},
  …
];

var line = d3.line()
  .x(d => xScale(d.date))
  .y(d => yScale(d.value));

d3.select('svg')
  .append('path')
  .attr('d', line(data));
```
1. Criam-se funções de escala com `d3.scale` (parâmetros: as escalas)
2. Cria-se função de linha com `d3.line()`, a partir das funções de escala.
3. Faz-se um append de um <path> no svg, cujo atributo `d` vai ser determinado pelo resultado da chamada da função de linha sobre os dados.
Obs.: Não precisa de `enter()`, pq só precisamos de um único elemento path. Só se usa enter-append quando não se tem ao certo o número de elementos que serão necessários. E não precisa do `data()` porque os dados já estão sendo passados como argumento da função geradora da linha.
Obs.2: O path é fechado, e por padrão o fundo é preto. Por isso, usar um `.attr('fill', 'none');`. Às vezes o padrão é `stroke`: `none`.

Para fazer a curva ficar err... curva, é só usar um `d3.curve...` na corrente do `d3.line()` (https://github.com/d3/d3-shape). Por exemplo, `d3.curveCatmullRom`, `d3.curveStep`...
> "Just one extra line additional whereas if you look under the hood the path d attributes are vastly different to render the different curves."

Para fazer um corte nos dados, lá dentro de `d3.tsv`:
```js
// em vez de data.forEach(d => {...})
data = data.slice(0, 100); // para pegar só os primeiros 100 datapoints (101, na verdade)
data.forEach(d => {...})

```

**Resumo**
`dados` --> 
funções criadas com `d3.scale()` --> 
função criada com `d3.line()` --> 
`d3.select('svg').append('path').attr('d', (`função criada com `d3.line()` aplicada`) )`


#### Pie charts with `d3.pie()`

Duas partes: 

*primeira parte*, `d3.pie()`: que vai simplesmente pegar os dados e gerar um objeto com os ângulos iniciais e finais que correspondem aos valores dos dados que foram passados.

```js
var pie = d3.pie();

// input
var data = [1, 1, 2, 3, 5, 8, 13, 21];

pie(data);

// output
[
  {"data":  1, "value":  1, "startAngle": 6.050474740247008, "endAngle": 6.166830023713296, "padAngle": 0},
  {"data":  1, "value":  1, "startAngle": 6.166830023713296, "endAngle": 6.283185307179584, "padAngle": 0},
  {"data":  2, "value":  2, "startAngle": 5.817764173314431, "endAngle": 6.050474740247008, "padAngle": 0},
  {"data":  3, "value":  3, "startAngle": 5.468698322915565, "endAngle": 5.817764173314431, "padAngle": 0},
  {"data":  5, "value":  5, "startAngle": 4.886921905584122, "endAngle": 5.468698322915565, "padAngle": 0},
  {"data":  8, "value":  8, "startAngle": 3.956079637853813, "endAngle": 4.886921905584122, "padAngle": 0},
  {"data": 13, "value": 13, "startAngle": 2.443460952792061, "endAngle": 3.956079637853813, "padAngle": 0},
  {"data": 21, "value": 21, "startAngle": 0.000000000000000, "endAngle": 2.443460952792061, "padAngle": 0}
]
```

*segunda parte*, pega-se o resultado da função criada com `d3.pie()` e passa-se para uma função criada com `d3.arc()`, gerando-se o código correspondente ao atributo `d` do <path>.

```js
  var colors = d3.scaleOrdinal(d3.schemeCategory10);
  var data = [1, 1, 2, 3, 5, 8, 13, 21];
  var pies = d3.pie()(data);

  var arc = d3.arc()
    .innerRadius(0)
    .outerRadius(150)
    .startAngle(d => d.startAngle)
    .endAngle(d => d.endAngle);

  var svg = d3.select('svg')
  	.append('g')
  	.attr('transform', 'translate(200,200)');
  svg.selectAll('path')
  	.data(pies).enter().append('path')
  	.attr('d', function(d) {return arc(d)}) // legal colocar um console.log(d, arc(d)) aqui!
  	.attr('fill', (d, i) => colors(d.value))
  	.attr('stroke', '#fff');
```

(as cores estão dentro de `d3.scale`, já que cores são basicamente um tipo de escala de categoria).

```js
let colors = d3.scaleOrdinal()
  .range(d3.schemeCategory10); // defino as cores de saída e não precisa passar um domain!
```

Muito do que d3 faz é converter dados em algo que <svg> ou <canvas> possa entender.

dados --> <<d3 magic, por meio de uma série de funções>> --> atributos de elementos de <svg> 
 

## Enter-Update-Exit

https://bost.ocks.org/mike/constancy/

```js
  // bars includes update selection
  var bars = svg.selectAll('rect')
    .data(data, d => d);

  // exit
  bars.exit().remove();

  // enter
  var enter = bars.enter().append('rect')
    .attr('width', rectWidth)
    .attr('stroke', '#fff');

  // enter + update
  bars = enter.merge(bars)
    .attr('x', (d, i) => i * rectWidth)
    .attr('y', d => height - d)
    .attr('height', d => d)
    .attr('fill', d => colors(d));
```

`bars` is the selection. Then the `.data()` will evaluate three selections:
* _update selection_, with the bound-elements that match the new data: `bars` (that is, what `.data`gives back)
* _enter  selection_, with the data not currently bound to the current elements `bars.enter()`
* _exit   selection_, with the bound-elements that don't match the new data. `bars.exit()`

all this matching is done via the KEY FUNCTION, which establishes the unique identifiers for every data point accross the datasets of all states.

In this example, the **exit selection** is being simply removed from the screen, with `.remove()`.

For the **enter selection**, Shirley likes to chain the attributes that don't depend on the data.



Dúvidas
======================================================

o que o `.data()` retorna? Ela faz o bind, mas retorna algo. É um array de elementos com os respectivos dados amarrados?

Acho confuso isso:

```js
let line = d3.line() // uma função?
  .x(d => xScale(d.date)) // outra função dentro daquela função? se .x fosse um método do objeto d3.line, 
                          // seria mais fácil de entender. mas esses parênteses junto de "line"?
  .y()
```

Um problema que vejo no entendimento inicial: muitas coisas são criadas como funções, mas os nomes das variáveis usadas são nomes de coisas, não de ações. Tipo "line", "xScale" etc. Nos meus códigos, acho que vou usar nomes de verbos.

o `.data()` parece ser uma forma simples de fazer um `.attr('data', valores)` em lote, iterado para cada elemento do dataset, e mesmo que não existam ainda os elementos que receberão esse atributo (criados com `.enter()` e `.append()`)

`.call`? (d3.selection) ( aparentemente, `svg.append('g').call(eixo_y)` equivale a `eixo_y(svg.append('g'))` )

como manipular um dataset no JS / D3?

tb ainda não está claro quando o uso de uma função de algum módulo do d3 retorna um valor ou uma outra função.

o que é um pouco confuso é pq, enquanto vc está aparentemente só definindo uma variável, ele já está aplicando as funções e produzindo um efeito no gráfico.

diferença de fazer um d3.select e um document.querySelector / .getElementsByTagName?

(como eram as seleções no JS mesmo?)

como selecionar parent, sibling etc., sem jquery?

`<rect>` properties?

como faz console log numa chamada do d3?

o que é o "0" em "_groups"?

no exercício 1, no código que processa o arquivo .tsv, o que é esse `++d[city]`? Ela usa isso para converter para um tipo numérico, mas como funciona exatamente?

```js
      let EixoY = svg //d3.select('svg')
        .append('g')
        .attr('transform', 'translate(' + [margin.left, 0] + ')') // como o eixo foi construído com o yScale, que por sua vez já fora construíndo levando-se em consideração as margins top e bottom, só precisamos posicioná-lo horizontalmente.
        .call(eixo_y);
      
      // na verdade nem precisaria nomear as variáveis, EixoX e EixoY. só fazer o svg.append('g')...
```
qual a melhor prática? só chamo a função, sem nomear a variável?



